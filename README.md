# THREADPOOL_Linux_C++

> 2021.10.10 -----> 2021.10.13

> 使用线程时去创建一个线程虽然方便，但是频繁的创建和销毁线程会造成时间上很大的开销。  

> 线程池以空间换时间，使用多个线程，无限制循环等待队列。处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。

本线程池由以下三个部分组成：任务队列、工作线程以及管理线程，使用生产者消费者模型。

### 1. 任务队列
> 存储待处理的任务
- 将待处理的任务添加到任务队列
- 已处理的任务会从任务队列中删除
- 任务队列是生产者消费者模型中的缓冲区
- 线程池的使用者，即往任务队列中添加任务的线程就是生产者线程

### 2. 工作线程
- 工作线程从任务队列中取出任务，是消费者
- 线程池有一定数量的工作线程，它们的任务是不停的读取任务队列，从任务队列中取出任务并进行处理
- 若任务队列为空，工作线程将会被阻塞
- 若阻塞之后任务队列中有了新的任务，生产者将阻塞解除，消费者开始工作

### 3. 管理者线程
- 周期性的对任务队列中的任务数量和处于繁忙状态的工作线程个数进行检测
    - 当任务过多时，适当的创建一些新的工作线程（线程总数不会超过设定的最大值）
    - 当任务过少时，适当的销毁一些工作线程


**参考资料**：  
1. https://www.cnblogs.com/lzpong/p/6397997.html
2. https://subingwen.cn/linux/threadpool/
3. https://wangpengcheng.github.io/2019/05/17/cplusplus_theadpool/